#!/usr/bin/python
# coding=utf-8

import sys
import pjsua as pj
import re
import logging as log

class Connection:
  collection = {}

  @staticmethod
  def create_if_new(incoming_call):
    for connection in Connection.collection.values():
      if connection.incoming_call.info().sip_call_id == incoming_call.info().sip_call_id:
        return
    connection = Connection(incoming_call)
    return connection

  def __init__(self, incoming_call):
    # Save the connection in class collection
    if len(Connection.collection) == 0:
      self.id = 0
    else:
      self.id = max(Connection.collection.keys()) + 1
    Connection.collection[self.id] = self

    # Mark calls as inactive
    self.active_incoming = False
    self.active_outgoing = False

    # Mark connection as not terminated
    self.terminated = False

    # Save incoming call parameters
    self.incoming_call = incoming_call

    self.incoming_number = self.extract_number(incoming_call.info().remote_uri)
    self.outgoing_number = self.extract_number(incoming_call.info().uri)

    # Create incoming call callback and set it on call
    incoming_call.set_callback(InCallCallback(self))

    # Create outgoing call
    out_cb = OutCallCallback(self)
    uri = self.sip_uri(self.outgoing_number)
    global outgoing_account
    log.debug("Calling {0}...".format(self.outgoing_number))
    self.outgoing_call = outgoing_account.make_call(uri, cb = out_cb)

  def answer_incoming(self):
    log.debug("Answering incoming call")
    self.incoming_call.answer()

  def bridge(self, callback):
    if isinstance(callback, InCallCallback):
      self.active_incoming = True
    if isinstance(callback, OutCallCallback):
      self.active_outgoing = True
    log.debug("Incoming: {0}, Outgoing: {1}".format(self.active_incoming,
        self.active_outgoing))
    if self.active_incoming and self.active_outgoing:
      in_slot = self.incoming_call.info().conf_slot
      out_slot = self.outgoing_call.info().conf_slot
      lib = pj.Lib.instance()
      lib.conf_connect(in_slot, out_slot)
      lib.conf_connect(out_slot, in_slot)
      # Realtime sniffing
      #lib.conf_connect(in_slot, 0)
      #lib.conf_connect(out_slot, 0)
      # Recording
      recorder = lib.create_recorder("{0}-{1}-{2}.wav".format(self.id,
        self.incoming_number, self.outgoing_number))
      recorder_slot = lib.recorder_get_slot(recorder)
      lib.conf_connect(in_slot, recorder_slot)
      lib.conf_connect(out_slot, recorder_slot)
      log.debug('Calls bridged')

  def terminate(self):
    lck = lib.auto_lock()
    if not self.terminated:
      self.terminated = True
      if self.incoming_call.info().state != pj.CallState.DISCONNECTED:
        self.incoming_call.hangup()
      if self.outgoing_call.info().state != pj.CallState.DISCONNECTED:
        self.outgoing_call.hangup()
      del Connection.collection[self.id]
      log.debug("Terminated connection {0}".format(self.id))
    del lck

  def extract_number(self, text):
    return re.match('^.*sip:(.+)@.+.freeconet.pl.*$', text).group(1)

  def sip_uri(self, number):
    return "sip:{0}@sip.freeconet.pl".format(number)

  def __str__(self):
    return "{0}: {1} > {2}".format(
      self.id, self.incoming_number, self.outgoing_number
    )

  @staticmethod
  def all():
    result = []
    for i in sorted(Connection.collection.keys()):
      result.append(Connection.collection[i])
    return result

class GlobAccountCallback(pj.AccountCallback):
  pass

class OutAccountCallback(GlobAccountCallback):
  pass

class InAccountCallback(GlobAccountCallback):
  def on_incoming_call(self, call):
    Connection.create_if_new(call)

class GlobCallCallback(pj.CallCallback):
  def __init__(self, connection):
    self.connection = connection
  def on_media_state(self):
    if self.call.info().media_state == pj.MediaState.ACTIVE:
      self.connection.bridge(self)
  def on_state(self):
    if self.call.info().state == pj.CallState.DISCONNECTED:
      self.connection.terminate()

class InCallCallback(GlobCallCallback):
  pass

class OutCallCallback(GlobCallCallback):
  def on_state(self):
    log.debug("Call state changed: {0}".format(self.call.info().state_text))
    GlobCallCallback.on_state(self)
    if self.call.info().state == pj.CallState.CONFIRMED:
      self.connection.answer_incoming()


# Logging callback for PJSIP library
def log_cb(level, str, len):
  log.debug(str),

# Parse arguments
args = sys.argv[1:]
try:
  args.index('-v')
except ValueError:
  log.basicConfig(level = log.FATAL)
  pj_debug = 0
else:
  log.basicConfig(level = log.DEBUG)
  pj_debug = 2

args = [e for e in args if e != '-v']

if len(args) != 2:
  print 'Usage:'
  print "  voiprox [-v] incoming_account outgoing_account\n"
  print 'Account has to be specified as username:password'
  print 'If your username or password has ":" sign then you are out of luck.'
  print 'Add -v for verbose/debug mode.'
  print 'Currently sip server is harcoded to sip.freeconet.pl.'
  exit(1)

in_params = args[0].split(':')
if len(in_params) != 2:
  print "Invalid incoming account specification"
in_user, in_pass = in_params

out_params = args[1].split(':')
if len(out_params) != 2:
  print "Invalid outgoing account specification"
out_user, out_pass = out_params

# Create library instance
lib = pj.Lib()

try:
  # Init library with default config and some customized
  # logging config.
  lib.init(log_cfg = pj.LogConfig(level=pj_debug, callback=log_cb))

  # Create UDP incoming_transport which listens to any available port
  incoming_transport = lib.create_transport(pj.TransportType.UDP,
                                   pj.TransportConfig(0))
  outgoing_transport = lib.create_transport(pj.TransportType.UDP,
                                   pj.TransportConfig(0))

  # Start the library
  lib.start()

  # Sig in
  sip_server = 'sip.freeconet.pl' # hardcoded, because not tested with other servers
  incoming_account = pj.AccountConfig(sip_server, in_user, in_pass)
  incoming_account = lib.create_account(incoming_account, cb=InAccountCallback())
  outgoing_account = pj.AccountConfig(sip_server, out_user, out_pass)
  outgoing_account = lib.create_account(outgoing_account, cb=OutAccountCallback())

  print 'VOIPROX 1.0 ready to intercept calls.'
  print 'Type "help" for a list of commands.'

  # Start command loop
  while(1):
    try:
      input = raw_input('>> ')
    except EOFError:
      print 'exit'
      break

    if input == '':
      continue

    # Extract command c, param1 p1 and param2 p2
    splitted = map(lambda x:x.lower(), input.split())
    c = splitted[0]
    params = [e for e in splitted[1:] if (e != 'to') and (e != 'from')]
    p1 = p2 = None
    if len(params) > 0:
      p1 = params[0]
    if len(params) > 1:
      p2 = params[1]

    # Typecast p1 and p2 to integers if possible
    try:
      p1 = int(p1)
    except TypeError, ValueError:
      pass
    try:
      p2 = int(p2)
    except TypeError, ValueError:
      pass

    # Commands processing logic goes here
    if c == 'quit' or c == 'exit':
      break
    elif c == 'list' or c == 'show':
      for connection in Connection.all():
        print connection
    elif c == 'disconnect':
      pass
    elif c == 'attach':
      pass
    elif c == 'detach':
      pass
    elif c == 'help':
      print "Possible commands:"
      print "  list, show       - show all active connections"
      print "  disconnect [[caller|callee] [from]] connection"
      print "                   - disconnect caller or calee from connection given by"
      print "                     connection id; if caller/callee not given entire "
      print "                     connection is terminated"
      print "  attach [mic|speaker] [to] connection"
      print "                   - attach local microphone or speaker to given connection;"
      print "                     if mic/speaker keyword not given both will be attached"
      print "  detach [mic|speaker] [from] connection - analogical to attach"
      print "  help             - show this help"
      print "  quit, exit or ^D - terminate all active connections and quit"
    else:
      print 'Unrecognized command, type "help" for a list of valid commands.'

  print 'Exiting... ',
  sys.stdout.flush()
  # Shutdown the library
  incoming_transport = None
  outgoing_transport = None
  incoming_account.delete()
  outgoing_account.delete()
  incoming_account = None
  outgoing_account = None
  lib.destroy()
  lib = None
  print 'done.'

except pj.Error, e:
  print "Exception: " + str(e)
  lib.destroy()
  lib = None
